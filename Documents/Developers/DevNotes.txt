
### Any tips or infomation ###

# Problem when yank and put block text
     When yank and put with block selection it makes inserting some spaces to pad a line.
  For example, assume we have following text:
  -----------------------
  aaaaaaa
  
  bbbbbbb
  -----------------------
  there is a blank line between two "a" and "b" lines and block selection from first "a" to first "b"
  makes ["a", "", "b"] as a selection. When yank this and put at 3rd "a" will results in padding 3 spaces
  in 2nd line to put ""(empty string). 
  The problem is that when Xcode's preference "Automatically trim trailing whitespaces" will delete the 
  spaces after putting the yanked text.
  It seems that it is not a big problem but when you want to "undo" the put operation you have to type
  "u" twice because the actions taken when we put are "Insert ["a", "", "b"] into each line" and "trim 
  trailing whitespace" and first "u" command only undo the "trim..." action.
  I tried to group them up into one action to undo with one "u" command but could not.
  

# How to control documents (Open, Close)
     NSString* filename = @"file path";
     NSError* error;
     NSURL* doc = [NSURL fileURLWithPath:filename];
     DVTDocumentLocation* loc = [[DVTDocumentLocation alloc] initWithDocumentURL:doc timestamp:nil];
     IDEEditorOpenSpecifier* spec = [IDEEditorOpenSpecifier structureEditorOpenSpecifierForDocumentLocation:loc inWorkspace:[XVimLastActiveWorkspaceTabController() workspace] error:&error];
     
     [IDEEditorCoordinator _doOpenIn_NewWindow_withWorkspaceTabController:XVimLastActiveWorkspaceTabController() documentURL:doc usingBlock:^(IDEEditorContext* context){
         [context _openEditorOpenSpecifier:spec updateHistory:NO];
     }];


  (Obsolite: Doesn't work after Xcode 7 GM)
  You can use IDEDocumentController. Its like...
     IDEDocumentController* ctrl = [IDEDocumentController sharedDocumentController];
     NSError* error;
     NSURL* doc = [NSURL fileURLWithPath:@"/foo/bar/test.h"];
     [ctrl openDocumentWithContentsOfURL:doc display:YES error:&error];



# Debugger area / Console Area
  To access the console area (debugger area), you can use

      IDEDefaultDebugArea* debuggerArea = [(IDEDefaultDebugArea*)[XVimLastActiveEditorArea() activeDebuggerArea];

  IDEDefaultDebuggerArea is an NSViewContoroller and has "varibles view" and "console view" as you can see in bottom of Xcode window.
  
  To access "console view" you can use

      IDEConsoleArea *console = [debuggerArea consoleArea];

  This is also an NSViewController.
  If you want to access its view you have to get the view but it does provide public property to access it.
  So we have to specify the instance varible name to get the view as below.

      IDEConsoleTextView* pView;
      object_getInstanceVariable(console , "_consoleView" , (void**)&pView);

  Now "pView" is IDEConsoleTextView (subclass of NSView)
  
  To insert text into the console view you can do like

      pView.logMode = 1;
      [pView insertText:@"some text"]

  I do not know what logMode is, but you have to enable it to insert text (otherwise you can not insert text).
  
  IDEConsoleArea has filterMode property. This property indicates the filter you can specify in console area.
  You can see "All Output", "Debugger Output", "Target Output" pulldown selection button on top of the console area.
  The values corresponds like

    0 - All Output
    1 - Debugger Output
    2 - Target Output
  
  
# DVTSourceTextview / DVTFoldingTextStorage / DVTTextStorage
  DVTSourceText view is a subclass of NSTextView.
  NSTextView has NSTextStorage to hold its content and DVTFoldingTextStorage is the claas corresponds it in Xcode.
  
  DVTFoldingTextStorage is handling string in a DVTSourceTextView with folding state.
  For example, we often have a placeholder in the text view (the highlighted words when you type some method)
  Internally it is just a text like "< # placholder #>" and it is showl as just "placeholder" with blue highlighted.
  (I put space between < and # above because Xcode automatically holds it if it is not there)
  In this case, DVTFoldingTextStorage will give a string "placeholder" to its text view.
  And DVTFoldingTextStorage has a property "realTextStorage"(DVTTextStorage) which holds internal text notation including < # part.
  So the length of the text is different between internal text notation and text acutually shown in the view.
  We have to handle these correctly when we calc the position in a text. We usually can just use a
  DVTFoldingTextStorage's methods but sometimes we need to know actual length in internal text.


# Exception occurs when you edit DVTFoldingTextStorage when the view is showing complition list
  When I tried to implement "hlsearch" I had to update text view (text storage) whenever they type (insert/delete) text because they produce
  some text which match/unmatch the currently search string.
  Highlighting a text is done via editing text storage object in a text view (DVTFoldingTextStorage in this case).
  So I update the storage whenever they type something. But it causes exceptions in DVTFoldinTextStorage.
  If I tried to edit the storage while the view is showing autocompletion it causes exception and break the completion feature.
  Currently I use NSTextViewDidChangeNotification to know when to update highlight state.


# Preferences
  Colors or some features on Xcode is configured via "Preferences" menu.
  Preferences are mainly managed by NSUserDefaults.
  But if you change NSUserDefaults directly it is not applied to Xcode views.
  (I think the views are listening to "Preference" controller and not the NSUserDefaults itself)
  
  What I found so far is that for text preferences you can use DVTTextPreferences class. (It took 5 hours to find this...)
  It has a class method which returns global singleton DVTTextPreferences object. When you set its property
  it properly affects views.
  It is like...
  
        [DVTTextPreferences preferences].showLineNumbers = YES;
        
        
# Thick insertion point(caret) drawing in NSTextView
  In NSTextView you can find a method "drawInsertionPointInRect:color:turnedOn:" which obviously draws insertion point.
  So it looks that overriding (or hooking) the method and just changing the "rect" is enough to achieve our goal.
  Unfortunately it does not work correctly.
  
  I here explain how the insertion point on a NSTextView is drawn.
  
  The method is fired by timer which is set by NSTextView internally. On each time it toggles "turnedOn:" argument
  so if the flag is ON you must draw insertion point and clear the insertion point when the flag is OFF.
  This makes a caret blinking.
  
  It is easy to draw insertion point but clearing insertion point is not so simple.
  Assume that you have a caret at the left side of a character and the caret and the character is overlapping.
  (Xcode's usual caret is only 1 or 2 pixels, so it is not big problem, but we will draw the thick caret as Vim does)
  When clearing a caret you have to redraw the character under the caret. To do so what you have to do is 
     - Clear the area (rect) of the caret with background color
     - Draw the (part of)character which resides in the rect
  
  Redrawing a specific area is a job done by drawRect: method (See Cocoa document). So acutual thing you should do in the
  drawInsertionInRect:... method is
     - Draw caret if the flag is ON
     - Call setNeedsDisplayInRect for the caret area if the flag is OFF. (This will lead drawRect being called)
  
  This is perhaps what default implementation of the NSTextView is doing
  
  so the pseudo code for the method is as following:
  
   - (void)drawInsertionPointInRect:(NSRect)rect color:(NSColor*)color turnedOn:(BOOL)flag{
      if( flag ){
          // Draw caret
          // NSTextView has a internal method to draw a caret
          [self _drawInsertionPointInRect:rect color:color];
      }else{
          // Clear caret
          // To clear firs they clear the rect which is previously drawn by _drawInsertionPointInRect:color: above
          // It is saved in internal varibale "_insertionPointRect"
          // So first clear the region of _insertionPointRect and then call following
          [self setNeedsDisplayInRect:_insertionPointRect];
      }
   }
  
   ( This code is from my analysis of the behaviour. No guarantee. )
   
   What this means is that NSTextView uses _drawInsertionPointInRect to draw the caret when the flag is ON.
   If the flag is OFF it calls setDisplayInRect: to redraw the previously drawn caret.
   The important thing is that NSTextView keeps its insertion point rect as internal variable named "_insertionPointRect"
  
   And one more thing we have to know about drawing insertion point.
   _drawInsertionPointInRect:color: method is also called from setSelectedRange method.
   When you move a cursor, it immediately changes the position of the caret. To achieve this,
   _drawInsertionPointInRect:color: is called.
   
   So everything in mind insertion point drawing methods should be like following.
  
   - (void)_drawInsertionPointInRect:(NSRange*)rect color:(NSColor*)color{
       // Some code...
  
       [color setFill];
       NSFillRect(rect);
      // Keep rect to clear this region later (when drawInsertionPointInRect is called with the flag OFF)
       _insertionPointRect = rect;
  
       // Some code...
   }
  
   - (void)drawInsertionPointInRect:(NSRect)rect color:(NSColor*)color turnedOn:(BOOL)flag{
      if( flag ){
          // Draw caret
          [self _drawInsertionPointInRect:rect color:color];
      }else{
          // Clear caret
          // To clear firs they clear the rect which is previously drawn by _drawInsertionPointInRect:color: above
          // It is saved in internal varibale "_insertionPointRect"
          // So first clear the region of _insertionPointRect and then call following
          [self setNeedsDisplayInRect:_insertionPointRect];
      }
   }
   
   - (void)setSelectedRange:(NSRange)range{
      // Some code...
      
      // Clear current caret useing _insertionPointRect
  
      // Calculate new caret rect from the range argument
      // And then
      [self _drawInsertionPointInRect:rect color:_insertionPointColor];
  
      // actual setSelectedRange is just a stub for setSelectedRange:affinity:stillSelecting:
   }
   
   - (void)insertionTimerExpired{
      // Calculate the caret rect from current selected range
      // And then
      _insertionPointOn = !_insertionPointOn; // Inverse the internal flag for insertoin point drawing.
      [self drawInsertionPointInRect:rect color:_insertionPointColor turnedOn:_insertionPointOn];
   }
  
  
   Now let us think how to make thick insertion point. Following actually works as we expect.
    - Hook drawInseritonPointInRect:color:flag
    - Resize the rect argument to fit into the character at insertion point. (make it thick)
    - Call original drawInsertionPointInRect...
  
   But we have a problems.
   _drawInsertionPointRect uses NSRectFill to draw insertion point which completely override the color of the text with the caret color.
   There is no transparency.
  
   The next thing we can think of is hooking _drawInsertionPointInRect:... method. 
   And draw insertion point without calling original _drawInsertionPointInRect:..
   It should be like this.
  
   - (void)_drawInsertionPointRect:(NSRect)rect color:(NSColor*)color{
      // Change rect to be fit to the character at the inseriton point. 
      // And then
      
      [color set];
  	NSRectFillUsingOperation( rect, NSCompositeSourceOver);
  
      // And do not call original _drawInsertionPointRect:...
   }
  
   This solves the problem. But we have another problem then.
   NSTextView keeps insertion point rect to clear the caret. If we do not call the original one NSTextView never has a chance 
   to keep the rect which results in that NSTextView never clears the caret. It means caret never blinks or
   drawn carets are stays on all the caracters it pass.
  
   So what we have to do is update _insertionPointRect varibles in NSTextView when we override _drawInsertionPointRect:... method.
   
   This is what XVim is currently doing. (See actual implementation in XVimSourceTextViewHook.m)


# Hilight Search
  To achieve hilight search XVim hooks 2 methods in DVTSourceTextView
     - didChangeText
     - drawRect
  
  In didChangeText XVim mark that we have to update found location by searching a text(last searched string).
  (We never do searching at this timing)
  
  In drawRect XVim update found locations if didChangeText marked that we need to update found locations.
  And then according to the locations drawRect sets text attribute for the ranges of found locations. And then draw the rect.
  
  The reason why we never do searching in didChangeText but just mark that an update is needed is that
  we cannot update found locations when a text view is initialized.
  We have to update found locations for a new content when new DVTSourceView and its content is updated.
  When Xcode changes text content to newly selected file (wehen you click a file in navigation pane) Xcode create new DVTSourceTextView and its text storage objects.
  We can know hen DVTSourceTextView is created by hooking initWithCoder method.
  But unfortunately I have not found any good method to hook to know when a "text" in DVTSourceTextView is initialized.
  A text in DVTSourceTextView is kept in DVTTextStorage and its subclasses but I could not find good property to observe.
  (No property change notifies us that the content is initialized.)
  This is one of reason why XVim tries update found locations if needed all the time it draws rect.
  
  To support to change highlighted locations when we put ":set hlsearch" or search new text, XVim sets up observing properties in XVimOption and XVimSearch object.
  
  See DVTSourceTextViewHook.m for the detail
  

# Handling DVTFoldingTextStorage (This is only for Xcode4)
  DVTSourceTextView has a DVTFoldingTextStorage as its text storage.
  The big difference between DVTFoldingTextStorage and NSTextStorage is supporting folding.
  In DVTFoldingTextStorage you can not simply calculate the character index. For example, text following
  
  abcd < #placeholder# >
  
  has a folding. DVTFoldingTextStorage represents place holder with '< #' and '# >'.  (I intentionally add space between < and # not to be handled as a placeholder here. In actual text there is no space.)
  The text above results in
  
  abcd placeholder
  
  where "placeholder" part is place holder(blue background color) and counted as one character.
  DVTFoldingTextStorage manages the relation between these 2 text and gives us an interface to access both.
  
  To access "raw" string representation you just call [storage string] method. This never considers a folding and returns "raw" string.
  If you want to know the length of raw string just call [storage string].length .
  
  To access "folded" string, before you call [storage string] you have to call [storage increaseUsingFoldedRanges] method.
  This method tells DVTFoldingTextStorage that we want to access "folded" representation of the storage. After calling this method
  all the method calls to the storage will be handled to the "folded" string. You have to call [storage decreaseUsingFoldedRanges] after 
  finished to access to the folded representation because someone else who are using it later considers that default state of the storage is
  "raw" string accessing mode.
  So usually what you have to write is
  
  [storage increaseUsingFoldedRanges];
  [storage string]; // or what ever you want to do on the folded string representation
  [storage decreaseUsingFoldedRanges];
  
  The example above has a text "abcd " and one placeholder.
  In this case the length of the string of folded representation is 6 (5 + 1 for placeholder).
  The character at placeholder returns 0xFFFC. This means the code below
  
  [storage increaseUsingFoldedRanges];
  unichar c = [[storage string] characterAtIndex:5];
  [storage decreaseUsingFoldedRanges];
  
  make 'c' to have 0xFFFC.
  
  0xFFFC is a NSAttachmentCharacter (See NSTextAttachment class reference).
  This means that this character is handled as an attachment by layout manager (DVTLayoutManager) and will be drawn as 
  a special glyph.
  
  In XVim, we usually do not want to handle "raw" representation of the folded storage but "folded" representation.
  So if we want to make some changes or calculate positions in a DVTFoldingTextStorage we usually need to call increaseUsingFoldedRanges.
  
  
# View Controllers and View relations

  Xcode has a lot of view controllers and associated views.
  Here is the hierarchy. Each entity is a class name or a property/method name Xcode uses.
  This is because sometimes it is not understandable the meaning of a entity only from its class name.
  Arrow represent has-a or has-many relation ship.
  
     Controllers                                   Window/Views
  
  IDEWorkspaceWindowController  -------------------------------->  IDEWorkspaceWindow  
   |
   |-> IDEWorkspaceTabController   ----------------------------->  designAreaSplitView(DVTSplitView)
        |                                                     |->  navReplacementView(DVTReplaceMentView)
        |                                                     |->  editorReplacementView(DVTReplacementView)
        |                                                     |->  utilityAreaSplitView (DVTSplitView)
        |                                                     |->  inspectorReplacementView (DVTReplacementView)
        |                                                     |->  libraryReplacementView (DVTReplacementView)
        |                                              
        |-> IDEEditorArea 
        |    |-> IDEEditorModeViewController(*1) 
        |    |      |-> primaryEditorContext ------------------->  IDEEditor (*2)
        |    |      |-> (secondaryEditorContext)
        |    |
        |    |-> IDEEditorContext(lastActiveEditorContext)
        |    |-> IDEDebugBar
        |    |-> IDEDebugArea
        |    |
        |    |-> lastActiveEditorContext(*3)
        |
        |-> IDENavigatorArea
        |
        |-> libraryArea
        |
        |-> inspectorArea
  
  
  
  (*1) IDEEditorModeViewController is a super class of following 3 classes
        - IDEEditorBasicMode
        - IDEEditorGeniusMode
        - IDEEditorVersionMode
       These 3 mode corresponds the icons on top right side of Xcode window labeled "Editor"
       Genius mode has 2 editor context (primary and secondary)
  
  
  (*2) IDEEditor is a common super class of all kinds of editors in Xcode.
       IDEEditor includes IDESourceCodeEditor, IDEComparisonEditor.
       These editors are provided plugins (See Xcode.app/Contents/Plugins directory).
       
  
  (*3) lastActiveEditorContext is a IDEEditorContext object which has had focus most recently.
  


# Navigator area structure (left pane of the window)

  IDWorkspaceWindowController
       |
       |-->(IDEWorkspaceTabController*)activeWorkspaceTabController
                   |
                   |-->(IDENavigatorArea*)navigatorArea
                           |
                           |-->(IDENavigator*)currentNavigator 
  
  
   IDENavigator includes
       - IDEStructureNavigaro (folder and files)
  
  
# Undo and Redoing
  One problem I had in Xcode 5.1 is in undoing.
  To simulate Vim's undoing we have to keep its original cursor position when operating on a text.
  NSTextView, NSUndoManager and NSTextStorage system does not keep its cursor position when registering undo operation. This means we can not simulate
  Vim's undoing only with these classes.
  
  In Xcode4 I did something like following when operating text. This keeps current cursor position to undo.
  
      [[self undoManager] registerUndoWithTarget:self selector:@selector(xvim_undoCursorPos:) object:[NSNumber numberWithUnsignedInteger:pos]];
  
  In the above, "self" is DVTSourceTextView.
  
  Unfortunately when switching files in Xcode5 it internally creates a new DVTSourceTextView and the registered text view is no longer available.
  This leads to a crash when you try to undo with the unavailable DVTSourceTextView.
  This can be reproduced with the following operations:
    - Open a document in Xcode
      (Let say the DVTSourceTextView used here is TextView1)
    - Operate something on the document
    - Switch to another document by selecting one in navigator view.
      (Now the new DVTSourceTextView  (TextView2) is used to show the document)
    - Switch back to the previous document.
      (Unfortunately at this point Xcode creates another new DVTSourceTextView (TextView3) to show the previous document)
    - Undo the operation
      This leads to a crash because the registered text view is TextView1 and it is no longer available.
      
  The root problem here is that we register DVTSourceTextView as the undo target. On the other hand NSTextView uses NSTextStorage as the undo target.
  
  So what we do is extend NSTextStorage to keep its original position.
  
  Usual undo registration sequence of NSTextView is following
   - operate on a text
      - creates "NSUndoTyping" object
      - obtain undo manager by NSTextView -undoManager method
      - obtain NSTextStorage by NSTextView -textStorage method
      - register undo with the NSUndoTyping object and the NSTextStorage as the target.
        (The selecter is internal method "_undoRedoTextOperation" in NSTextStorage)
   
   When undo in NSTextView the following occurs (probably):
  
   - call NSUndoManger's -undo method
   - call registered NSTextStoage's "_undoRedoTextOperation" with NSUndoTyping object
      
 
# IDESourceCodeEditor and DVTSourceTextView
  IDESourceCodeEditor controls DVTSourceTextView
  To obtain IDESourceCodeEditor from DVTSourceTextView you can use delegate property.
  (It may not be set so we should test if it is nil)
  

# IDESourceCodeEditor and Views and Documents(Xcode5)
  DVTSourceTextView
   |-undoManager   ------------------------------------------------------------------------
   |-delegate  ------------> IDESourceCodeEditor
   |-textStorage                                                                          | 
      |                                                                                   |
      v                                                                                   |                  
  DVTTextStorage.delegate ---------> IDESourceCodeDocument                                v
                                                 |--- undoManager ----------------> DVTUndoManager
                 

# How NSTextView updates insertionpoint when undoing
  When you modify text in NSTextView, it modifies NSTextStorage.
  NSTextStorage then add an NSUndoTextOperation object to NSUndoManager by calling registerUndoWithTarget:selector:object: method.
  This method takes target and object. 
  The target is NSTextStorage and the object is the NSUndoTextOperation object.
  
  NSUndoTextOperation holds information about undoing (the range of affected text).
  
  When undoing, NSUndoManager calls NSTextStorage's internal method _undoRedoTextOperation method (with an argument of NSUndoTextOperation object)
  Then NSUndoManager invokes undoRedo: method in NSUndoTextOperation object (it must takes the NSTextStorage object as its argument).
  
  The important thing to notice here is NSUndoTextOperation does not know NSTextView object related to the NSTextStorage.
  undoRedo: method should modify NSTextStorage object and updates text in it but can not make any change about current insertion point.
  
  Actually what AppKit does is just obtaining NSTextView object related to NSTextStorage by calling 
   [[[NSTextStorage layoutMangaers] firstObject] firstTextView]
  
  
  
# Investigation for opening a file in IDEEditorArea
  It seems that IDEDocumentController's openDocumentWithContentsOfURL:display:error: is no longer used in Xcode 7 (This leads immediate assertion error). This method is used to open a document from XVim.
  So to open a document I investigated how acutally Xcode 7 (and maybe from before that version) opening a file.
  
  Since my first goal was to open a file in a new window, I investigated how it works when double click a file in navigator area. Here's a sample call stack.

  #0   -[IDEEditorContext _openEditorOpenSpecifier:updateHistory:] ()
  #1   -[IDEEditorContext openEditorOpenSpecifier:] ()
  #2   -[IDEEditorModeViewController openEditorOpenSpecifier:editorContext:] ()
  #3   -[IDEEditorArea _openEditorOpenSpecifier:editorContext:takeFocus:] ()
  #4   __108+[IDEEditorCoordinator _doOpenEditorOpenSpecifier:forWorkspaceTabController:editorContext:target:takeFocus:]_block_invoke ()
  #5   +[IDEEditorCoordinator _doOpenIn_NewWindow_withWorkspaceTabController:documentURL:usingBlock:] ()
  #6   +[IDEEditorCoordinator _doOpenIn_SeparateWindow_withWorkspaceTabController:documentURL:usingBlock:] ()
  #7   +[IDEEditorCoordinator _doOpenWithWorkspaceTabController:editorContext:target:allowFallback:documentURL:usingBlock:] ()
  #8   +[IDEEditorCoordinator _doOpenEditorOpenSpecifier:forWorkspaceTabController:editorContext:target:takeFocus:] ()
  #9   -[_IDEOpenRequest _runIfNecessary] ()
  #10  -[_IDEOpenRequest _enqueueForEventBehavior:] ()
  #11  +[IDEEditorCoordinator _openRequestForEditorOpenSpecifier:workspaceTabController:editorContext:eventBehavior:takeFocus:] ()
  #12  __99+[IDEEditorCoordinator _openEditorOpenSpecifier:forWorkspaceTabController:eventBehavior:takeFocus:]_block_invoke ()
  #13  +[IDEEditorCoordinator _performBlockInsideReentrantGuard:] ()
  #14  +[IDEEditorCoordinator _openEditorOpenSpecifier:forWorkspaceTabController:eventBehavior:takeFocus:] ()
  #15  +[IDEEditorCoordinator openEditorOpenSpecifier:forWorkspaceTabController:eventType:] ()
  #16  -[IDEOutlineBasedNavigator _openNavigableItem:eventType:] ()
  #17  -[IDEOutlineBasedNavigator openDoubleClickedNavigableItemsAction:] ()
  #18  _os_activity_initiate ()
  #19  -[NSApplication sendAction:to:from:] ()
  #20  __37-[DVTApplication sendAction:to:from:]_block_invoke ()
  #21  DVTInvokeWithFailureHint ()
  #22  -[DVTApplication sendAction:to:from:] ()
  #23  -[NSControl sendAction:to:] ()
  #24  -[IDENavigatorOutlineView sendAction:to:] ()
  #25  -[NSTableView _sendAction:to:row:column:] ()
  #26  -[NSTableView mouseDown:] ()
  #27  -[NSOutlineView mouseDown:] ()
  #28  -[IDENavigatorOutlineView mouseDown:] ()
  #29  -[NSWindow _reallySendEvent:isDelayedEvent:] ()
  #30  -[NSWindow sendEvent:] ()
  #31  -[IDEWorkspaceWindow sendEvent:] ()
  #32  -[NSApplication sendEvent:] ()
  #33  -[IDEApplication sendEvent:] ()
  #34  -[NSApplication run] ()
  #35  NSApplicationMain ()
  
  
  Opening file event starts from mouseDown (double click) event on a "NavigableItem" which represents an item in navigator area.
  The first notable thing is IDEEditorCoordinator class has main role when opening a file. The class has many class methods.
  It looks like it is a kind of utility class to open a file in new windows or new tabs.
  Entry point for opening a file in new window is 

      #5   +[IDEEditorCoordinator _doOpenIn_NewWindow_withWorkspaceTabController:documentURL:usingBlock:] ()

  This will open a new window and call the block that passed to "usingBlock:".
  The block signature is something like

      ^(IDEEditorContext* context){...} 

  This means it provides us new IDEEditorContext in a new window.
  To open a document in the IDEEditorContext, call

      #3   -[IDEEditorArea _openEditorOpenSpecifier:editorContext:takeFocus:] ()
    or
      #0   -[IDEEditorContext _openEditorOpenSpecifier:updateHistory:] ()
     
  IDEEditrArea can be obtained from IDEEditorContext object.
  The first argument is IDEEditorOpenSpecifier. This can be created from DVTDocumentLocation which in turn can be created from NSURL.
  
  So to open a new file in new window, it is like

      NSError* error;
      NSURL* doc = [NSURL fileURLWithPath:filename];
      DVTDocumentLocation* loc = [[DVTDocumentLocation alloc] initWithDocumentURL:doc timestamp:nil];
      IDEEditorOpenSpecifier* spec = [IDEEditorOpenSpecifier structureEditorOpenSpecifierForDocumentLocation:loc inWorkspace:[XVimLastActiveWorkspaceTabController() workspace] error:&error];
      
      // IDEDocumentController* ctrl = [IDEDocumentController sharedDocumentController];
      // [ctrl openDocumentWithContentsOfURL:doc display:YES error:&error]; // This doesn't work anymore after Xcode 7 GM
      
      [IDEEditorCoordinator _doOpenIn_NewWindow_withWorkspaceTabController:XVimLastActiveWorkspaceTabController() documentURL:doc usingBlock:^(IDEEditorContext* context){
          // Do something on the context
          [context _openEditorOpenSpecifier:spec updateHistory:YES];
      }];
  
  If you want to open a file in current window, just call with the last active editor area.
      #3   -[IDEEditorArea _openEditorOpenSpecifier:editorContext:takeFocus:] ()
    or
      #0   -[IDEEditorContext _openEditorOpenSpecifier:updateHistory:] ()
  
  There are other similar class methods that seem to work as well in IDEEditorCoordinator class.
  
